<script>

/*
 * Glossary Tooltip Auto-Linker (Web Awesome + HTMX)
 * -------------------------------------------------
 * - Fetches glossary JSON mapping { term/alias -> slug }
 * - Finds the FIRST occurrence of each unique slug across paragraphs, blockquotes, and headings
 * - Wraps the match with a focusable span trigger
 * - Appends a corresponding <wa-tooltip trigger="manual"> at the end of <body>
 * - Wires stable, non-janky hover intent using relatedTarget-aware handlers
 * - Ensures only one tooltip per slug (aliases won't duplicate)
 *
 * Assumptions:
 * - Web Awesome is already loaded on the page.
 * - HTMX is optional but supported for loading /glossary/<slug>/partial.
 * - Tailwind classes exist in your project (for provided styles).
 *
 * Public API:
 *   window.GlossaryTooltips.init(options?)
 *     options:
 *       - glossaryUrl: string (default: "/glossary.json")
 *       - root: Element|Document (default: document) — scope to scan/insert
 *       - placement: string (default: "bottom-start") — tooltip placement
 *       - distance: string|number (default: 12) — gap between trigger and tooltip
 *
 * Behavior on re-runs:
 * - Will NOT recreate tooltips for slugs that already have a trigger element id of `${slug}-gloss-item` in the DOM.
 * - Useful with HTMX swaps: we re-scan only the provided root.
 */
(() => {
  const DEFAULTS = {
    glossaryUrl: "/glossary.json",
    root: document,
    placement: "bottom-start",
    distance: 12,
  };

  // Cache glossary and keep a global record of wired pairs
  let _glossaryCache = null; // Map(termLower -> slug)

  // Global: keep one tooltip open at a time to minimize weird overlaps
  let _currentOpenTooltip = null;

  // ---------- Utilities ----------

  // Title Case helper for CTA text
  const toTitle = (s) => s.replace(/\w\S*/g, w => w[0].toUpperCase() + w.slice(1));

  // Safe ID builders (one trigger/tooltip per slug)
  const triggerIdFor = (slug) => `${slug}-gloss-item`;
  const tooltipIdFor = (slug) => `${slug}-gloss-tooltip`;

  // Word-boundary-ish regex that won't split inside alphanumerics
  const termRegex = (term) => {
    const escaped = term.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    return new RegExp(`(?<![A-Za-z0-9])(${escaped})(?![A-Za-z0-9])`, "i");
  };

  // Replace the first match of rx within root text nodes, skipping links/code/etc.
  function wrapFirstMatchInElement(root, rx, makeEl) {
    const walker = document.createTreeWalker(root, NodeFilter.SHOW_TEXT, {
      acceptNode(node) {
        if (!node.nodeValue || !node.nodeValue.trim()) return NodeFilter.FILTER_REJECT;
        const p = node.parentElement;
        if (!p) return NodeFilter.FILTER_REJECT;
        if (p.closest("a, code, pre, kbd, samp, button, textarea, .no-glossary, [contenteditable='true']")) {
          return NodeFilter.FILTER_REJECT;
        }
        return NodeFilter.FILTER_ACCEPT;
      }
    });

    let textNode;
    while ((textNode = walker.nextNode())) {
      const m = rx.exec(textNode.nodeValue);
      if (!m) continue;

      const before = textNode.nodeValue.slice(0, m.index);
      const match  = textNode.nodeValue.slice(m.index, m.index + m[0].length);
      const after  = textNode.nodeValue.slice(m.index + m[0].length);

      const frag = document.createDocumentFragment();
      if (before) frag.appendChild(document.createTextNode(before));

      const el = makeEl(match);
      frag.appendChild(el);

      if (after) frag.appendChild(document.createTextNode(after));

      textNode.parentNode.replaceChild(frag, textNode);
      return el; // only one occurrence per call
    }
    return null;
  }

  // relatedTarget-aware, single-owner hover wiring
  function wireManualTooltip(anchorEl, tooltipEl, { placement, distance }) {
    // Defensive defaults to avoid overlap flicker and tiny-hover targets
    if (!tooltipEl.getAttribute('placement')) tooltipEl.setAttribute('placement', placement);
    if (!tooltipEl.getAttribute('distance')) tooltipEl.setAttribute('distance', String(distance));

    let closeTimer = null;

    const openTip = () => {
      clearTimeout(closeTimer);
      if (_currentOpenTooltip && _currentOpenTooltip !== tooltipEl) {
        _currentOpenTooltip.open = false;
      }
      tooltipEl.open = true;
      _currentOpenTooltip = tooltipEl;
    };

    const scheduleClose = (delay = 160) => {
      clearTimeout(closeTimer);
      closeTimer = setTimeout(() => {
        // Only close if pointer is in neither element
        if (!anchorEl.matches(':hover') && !tooltipEl.matches(':hover')) {
          tooltipEl.open = false;
          if (_currentOpenTooltip === tooltipEl) _currentOpenTooltip = null;
        }
      }, delay);
    };

    const leavingToOther = (e) => e.relatedTarget && (anchorEl.contains(e.relatedTarget) || tooltipEl.contains(e.relatedTarget));

    // Trigger side
    anchorEl.addEventListener('pointerenter', openTip);
    anchorEl.addEventListener('pointerleave', (e) => {
      if (leavingToOther(e)) return; // cross-bridge
      scheduleClose(220);
    });

    // Tooltip side
    tooltipEl.addEventListener('pointerenter', openTip);
    tooltipEl.addEventListener('pointerleave', (e) => {
      if (leavingToOther(e)) return;
      scheduleClose(140);
    });

    // a11y & escape
    anchorEl.addEventListener('focusin', openTip);
    anchorEl.addEventListener('focusout', (e) => {
      if (leavingToOther(e)) return;
      scheduleClose(120);
    });
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape' && tooltipEl.open) {
        tooltipEl.open = false;
        if (_currentOpenTooltip === tooltipEl) _currentOpenTooltip = null;
      }
    });
  }

  // Build the tooltip element HTML for a slug
  function buildTooltip(slug) {
    const tip = document.createElement('wa-tooltip');
    tip.setAttribute('for', triggerIdFor(slug));
    tip.setAttribute('id', tooltipIdFor(slug));
    tip.setAttribute('trigger', 'manual');
    tip.innerHTML = `
      <div class="bg-black rounded-xl border-2 border-pink-500 max-h-96 overflow-y-scroll">
        <a class="bg-pink-500 text-white uppercase mx-4" href="/glossary/${slug}" style="color:white">${toTitle(slug.replace(/-/g, ' '))}</a>
        <div hx-get="/glossary/${slug}/partial" hx-swap="outerHTML" hx-trigger="load"></div>
        <wa-include src="/glossary/${slug}/partial"></wa-include>
      </div>
    `.trim();
    return tip;
  }

  // Main init routine
  async function init(options = {}) {
    const opts = { ...DEFAULTS, ...options };

    // Fetch glossary once (cache)
    if (!_glossaryCache) {
      try {
        const res = await fetch(opts.glossaryUrl, { credentials: 'same-origin' });
        const json = await res.json();
        const m = new Map();
        Object.entries(json).forEach(([k, v]) => m.set(String(k).toLowerCase().trim(), String(v).trim()));
        _glossaryCache = m;
      } catch (e) {
        console.warn('[glossary-tooltips] Failed to fetch glossary JSON:', e);
        return;
      }
    }

    const root = opts.root || document;

    // Build a fast lookup of which slugs already exist as triggers in DOM
    const existingSlugSet = new Set(
      Array.from(document.querySelectorAll('[id$="-gloss-item"]'))
        .map(el => el.id.replace(/-gloss-item$/, ''))
    );

    const TARGET_SELECTOR = 'p, blockquote, h1, h2, h3, h4, h5, h6';
    const blocks = Array.from(root.querySelectorAll(TARGET_SELECTOR));

    // Iterate terms in insertion order; skip if slug already present
    for (const [termLower, slug] of _glossaryCache.entries()) {
      if (existingSlugSet.has(slug)) continue; // one per slug globally

      const rx = termRegex(termLower);
      let insertedEl = null;

      for (const block of blocks) {
        insertedEl = wrapFirstMatchInElement(block, rx, (matchedText) => {
          const span = document.createElement('span');
          // span.href = `/glossary/${slug}`;
            span.style='color:white'
          span.className = 'bg-pink-500 text-white px-1 rounded cursor-pointer';
          span.id = triggerIdFor(slug);
          span.textContent = matchedText; // preserve original casing
          span.tabIndex = 0; // a11y focusable
          return span;
        });
        if (insertedEl) break; // found a spot for this slug
      }

      if (!insertedEl) continue; // no match in this root

      // Append tooltip once per slug at the end of body
      const tip = buildTooltip(slug);
      document.body.appendChild(tip);

      // Wire behavior
      const trigger = document.getElementById(triggerIdFor(slug));
      wireManualTooltip(trigger, tip, { placement: opts.placement, distance: opts.distance });

      // Track to avoid duplicates within same run
      existingSlugSet.add(slug);
    }
  }

  // Expose API
  window.GlossaryTooltips = { init };

  // Auto-run on DOM ready for the whole document
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => init());
  } else {
    init();
  }

  // Re-scan only swapped content when HTMX updates the page
  document.addEventListener('htmx:afterSwap', (e) => {
    // Only scan the swapped region to minimize work
    window.GlossaryTooltips.init({ root: e.target });
  });
})();
</script>
